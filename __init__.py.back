bl_info = {
    "name": "DD FBX Importer",
    "author": "Yu-Lit",
    "version": (0, 0, 1),
    "blender": (4, 1, 0),
    "location": "",
    "description": "",
    "warning": "",
    "support": "COMMUNITY",
    "doc_url": "",
    "tracker_url": "",
    "category": "",
}


if "bpy" in locals():
    import importlib

    reloadable_modules = [
        "preparation_logger",
        "debug",
    ]

    for module in reloadable_modules:
        if module in locals():
            importlib.reload(locals()[module])

else:
    from .Logging import preparation_logger
    from . import debug


import bpy

from bpy_extras.io_utils import orientation_helper

from .debug import (
    launch_debug_server,
)


"""---------------------------------------------------------
------------------------------------------------------------
    Logger
------------------------------------------------------------
---------------------------------------------------------"""
from .Logging.preparation_logger import preparating_logger

logger = preparating_logger(__name__)


"""---------------------------------------------------------
------------------------------------------------------------
    Property Group
------------------------------------------------------------
---------------------------------------------------------"""


"""---------------------------------------------------------
------------------------------------------------------------
    Operator
------------------------------------------------------------
---------------------------------------------------------"""


class DDFBXIMPORT_OT_fbx_import(bpy.types.Operator):
    """Test importer that creates scripts nodes from .txt files"""

    bl_idname = "ddfbx.fbx_import"
    bl_label = "D&D Import FBX"

    """
    This Operator can import multiple .txt files, we need following directory and files
    properties that the file handler will use to set files path data
    """
    directory: bpy.props.StringProperty(subtype="FILE_PATH", options={"SKIP_SAVE"})
    files: bpy.props.CollectionProperty(type=bpy.types.OperatorFileListElement, options={"SKIP_SAVE"})

    @classmethod
    def poll(cls, context):
        return context.area and context.area.type == "VIEW_3D"

    def execute(self, context):
        import os

        os.system("cls")
        logger.debug("Execute D&D")
        """The directory property need to be set."""
        if not self.directory:
            return {"CANCELLED"}
        for file in self.files:
            """
            Calls to the operator can set unfiltered file names,
            ensure the file extension is .txt
            """
            from pathlib import Path

            filepath = Path(self.directory).joinpath(file.name)
            logger.debug(filepath)
            bpy.ops.import_scene.fbx(filepath=str(filepath))

        return {"FINISHED"}


"""---------------------------------------------------------
------------------------------------------------------------
    File Handler
------------------------------------------------------------
---------------------------------------------------------"""


class DDFBXIMPORT_FH_fbx_import(bpy.types.FileHandler):
    bl_idname = "DDFBXIMPORT_FH_custom_fbx_import"
    bl_label = "File Handler for Custom FBX Import"
    bl_import_operator = "ddfbx.fbx_import"
    bl_file_extensions = ".fbx"

    @classmethod
    def poll_drop(cls, context):
        return context.area and context.area.type == "VIEW_3D"


"""---------------------------------------------------------
------------------------------------------------------------
    REGISTER/UNREGISTER
------------------------------------------------------------
---------------------------------------------------------"""
CLASSES = (
    DDFBXIMPORT_OT_fbx_import,
    DDFBXIMPORT_FH_fbx_import,
)


def register():
    logger.debug("Register")
    for cls in CLASSES:
        try:
            bpy.utils.register_class(cls)
        except:
            logger.debug(f"{cls.__name__} : already registred")

    ## Property Group の登録

    # デバッグ用
    # launch_debug_server()


def unregister():
    for cls in CLASSES:
        if hasattr(bpy.types, cls.__name__):
            bpy.utils.unregister_class(cls)
            logger.debug(f"{cls.__name__} unregistred")
